@startuml C4_Code_Optimization_Engine
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

title Code-level diagram for Rest Optimization Engine

package "app.services.rest_optimization" {
    class RestOptimizationEngine {
        +recommend_rest(input_data: RestOptimizationInput): RestOptimizationResult
        -_analyze_dock_time(dock_duration: float, required_rest: float): bool
        -_analyze_post_load_demand(route_data: dict): float
        -_calculate_opportunity_score(dock_time: float, drive_demand: float, hos_status: dict): float
        -_determine_rest_type(dock_time: float, hos_status: dict): RestType
        -_generate_recommendation_reason(analysis: dict): str
    }

    enum RestType {
        FULL_REST
        PARTIAL_REST
        NO_REST
    }

    class RestOptimizationInput {
        +driver_id: str
        +hours_driven: float
        +on_duty_time: float
        +hours_since_break: float
        +dock_duration_hours: float
        +remaining_route_miles: float
        +destination: str
        +appointment_time: Optional[datetime]
    }

    class RestOptimizationResult {
        +recommendation: RestType
        +recommended_duration_hours: float
        +reason: str
        +compliance_status: HOSComplianceResult
        +opportunity_score: float
        +estimated_drive_demand: float
        +metadata: dict
    }
}

package "app.services.hos_rule_engine" {
    class HOSRuleEngine {
        +validate_compliance(...): HOSComplianceResult
    }

    class HOSComplianceResult {
        +is_compliant: bool
        +hours_remaining_to_drive: float
        +rest_required: bool
    }
}

package "app.services.prediction_engine" {
    class PredictionEngine {
        +estimate_drive_demand(route_data: dict): PredictionResult
    }

    class PredictionResult {
        +estimated_drive_hours: float
        +estimated_arrival: datetime
        +confidence: float
    }
}

package "app.repositories" {
    class DriverRepository {
        +get_by_driver_id(driver_id: str): Driver
    }

    class RouteRepository {
        +get_by_id(route_id: int): Route
        +get_active_route(driver_id: str): Route
    }

    class RecommendationRepository {
        +create(recommendation: dict): Recommendation
        +get_history(driver_id: str): List[Recommendation]
    }
}

package "app.models" {
    class Recommendation {
        +id: int
        +driver_id: str
        +recommendation_type: str
        +duration_hours: float
        +reason: str
        +opportunity_score: float
        +created_at: datetime
    }
}

RestOptimizationEngine --> HOSRuleEngine : validates compliance
RestOptimizationEngine --> PredictionEngine : estimates demand
RestOptimizationEngine --> DriverRepository : fetches driver
RestOptimizationEngine --> RouteRepository : fetches route
RestOptimizationEngine --> RecommendationRepository : stores result

RestOptimizationEngine ..> RestOptimizationInput : receives
RestOptimizationEngine ..> RestOptimizationResult : returns
RestOptimizationResult *-- RestType : contains
RestOptimizationResult *-- HOSComplianceResult : contains
RestOptimizationResult *-- PredictionResult : includes

RecommendationRepository --> Recommendation : creates

note right of RestOptimizationEngine
  **Decision Algorithm:**
  1. Validate HOS compliance first
  2. Calculate post-load drive demand
  3. Compare dock time vs required rest
  4. Calculate opportunity score
  5. Determine rest type:
     - FULL_REST: dock ≥ 10hrs AND demand ≤ threshold
     - PARTIAL_REST: dock ≥ 7hrs AND split allowed
     - NO_REST: insufficient dock time
  6. Generate detailed reasoning
  7. Store recommendation for audit
end note

note bottom of RestType
  **Rest Types:**
  - FULL_REST: 10-hour sleeper berth
  - PARTIAL_REST: 7/3 or 8/2 split
  - NO_REST: Continue without rest
end note

@enduml
