---
title: Architecture Overview
description: Understand SALLY's system architecture and design principles
---

# Architecture Overview

SALLY is a compliance-first route planning platform that optimizes fleet operations through intelligent automation and continuous monitoring.

## System Overview

SALLY combines route optimization, HOS compliance validation, and real-time monitoring into a unified platform that helps dispatchers create feasible routes and coordinate with drivers effectively.

### Core Capabilities

- **Route Planning with Stop Sequence Optimization** - TSP/VRP algorithms minimize time and cost
- **Automatic Rest Stop Insertion** - HOS-aware planning inserts rest stops where needed
- **Automatic Fuel Stop Insertion** - Range-based optimization inserts fuel stops
- **HOS Compliance Validation** - Zero violations through segment-by-segment simulation
- **Dynamic Route Updates** - 14 trigger types monitored 24/7
- **Continuous Monitoring** - Proactive and reactive event detection
- **Automated Dispatcher Alerts** - Driver status, HOS, dock delays, and more
- **Dual User Interfaces** - Dispatcher dashboard and driver view
- **Mock External API Integrations** - Samsara HOS, fuel prices, weather, TMS (POC)

## Three-Layer Architecture

SALLY's architecture is organized into three distinct layers, each with specific responsibilities:

### Layer 1: Route Planning Engine (Primary)

The core planning engine that generates optimized, HOS-compliant routes.

**Responsibilities:**
- TSP optimization for stop sequence
- Segment-by-segment HOS simulation
- Rest stop insertion (calls REST Optimization Engine)
- Fuel stop insertion based on range and price
- Feasibility validation before driver assignment

**Key Components:**
- **Route Planner** - Orchestrates the planning process
- **TSP Optimizer** - Solves traveling salesman problem (greedy + 2-opt)
- **HOS Simulator** - Validates compliance for every segment
- **REST Optimization Engine** - Recommends rest timing and type
- **Fuel Optimizer** - Finds cheapest fuel stops on route

**Output:**
- Complete route with optimized stop sequence
- Drive, rest, fuel, and dock segments
- HOS compliance validation
- Feasibility report (can driver complete this route?)

### Layer 2: Continuous Monitoring Service

A background service that monitors all active routes and detects conditions requiring intervention.

**Responsibilities:**
- Monitor 14 trigger types across 5 categories
- Run every 60 seconds per active route
- Proactive HOS monitoring (warn before violations)
- Reactive violation handling (force rest after violations)
- Generate dispatcher alerts when intervention needed

**Trigger Categories:**
1. **HOS-Related** - Approaching limits, violations, break requirements
2. **Dock-Related** - Time exceeded, early/late arrival
3. **Traffic-Related** - Delays, road closures
4. **Load-Related** - Added, cancelled, modified
5. **Driver-Related** - Not moving, rest request, delay report

**Alert Engine:**
- Generates alerts with priority levels (CRITICAL, HIGH, MEDIUM, LOW)
- Stores alert records in database
- Exposes API for dispatcher dashboard
- Recommends actions for each alert type

### Layer 3: Dynamic Update Handler

The orchestrator that decides when routes need re-planning and manages the update process.

**Responsibilities:**
- Receive triggers from Monitoring Service
- Threshold-based re-plan decision
- Invoke Route Planning Engine for new routes
- Increment plan versions (v1 → v2)
- Notify drivers and dispatchers
- Maintain audit trail

**Re-Plan Logic:**
```
IF impact > threshold (e.g., 30min ETA delay):
  → Full re-plan
  → May re-sequence stops
  → May insert/remove rest stops
  → Version increments
ELSE:
  → ETA update only
  → No route changes
```

**Update Flow:**
```
Trigger Detected → Impact Analysis → Decision (Re-plan vs Update)
  → Route Planning (if needed) → Notification → Audit Log
```

## How the Layers Work Together

```
┌─────────────────────────────────────────────────┐
│  Layer 2: Continuous Monitoring (60s loop)     │
│  - Monitors all active routes                   │
│  - Detects: dock delay 2h over estimate         │
│  - Triggers alert: DOCK_TIME_EXCEEDED           │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  Layer 3: Dynamic Update Handler               │
│  - Calculates impact: 2h delay affects HOS      │
│  - Decision: Re-plan needed (impact > 30min)    │
│  - Invokes Layer 1 for new route               │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────┐
│  Layer 1: Route Planning Engine                │
│  - Input: Current location, updated HOS state   │
│  - Re-sequences remaining stops                 │
│  - Inserts additional rest stop (HOS required)  │
│  - Returns: New route (Plan v2)                │
└──────────────────┬──────────────────────────────┘
                   │
                   ▼
         Driver & Dispatcher Notified
```

## REST Optimization Integration

The REST Optimization Engine is a **component** (not the primary product) called by the Route Planning Engine when HOS simulation detects a shortfall.

**Decision Flow:**
```
Route Planner (simulating segment)
    ↓
Detects: hours_remaining < hours_needed
    ↓
Calls: REST Optimization Engine
    ↓
Analyzes: Current HOS, dock time, remaining route
    ↓
Returns: Recommendation (rest type, duration, reasoning)
    ↓
Route Planner: Inserts rest segment
```

**Recommendation Types:**
- **FULL_REST** (10h) - Resets all hours (11h drive + 14h duty)
- **PARTIAL_REST** (7h/8h) - Sleeper berth split (7/3 or 8/2)
- **NO_REST** - Leverage dock time for compliance

**Decision Factors:**
- Current HOS state (proximity to limits)
- Remaining route demand (hours needed)
- Dock time availability (can leverage downtime?)
- Cost analysis (extra time vs compliance risk)
- Opportunity score (0-100)

## Technology Stack

SALLY is built as a modern monorepo with Python backend and TypeScript frontend.

### Backend Stack

| Technology | Version | Purpose |
|-----------|---------|---------|
| **Python** | 3.11+ | Backend language |
| **FastAPI** | Latest | Async web framework |
| **PostgreSQL** | 16 | Primary database |
| **Redis** | 7 | Cache and session storage |
| **SQLAlchemy** | 2.0 | Async ORM |
| **Pydantic** | v2 | Data validation |
| **UV** | Latest | Package manager |
| **Alembic** | Latest | Database migrations |

### Frontend Stack

| Technology | Version | Purpose |
|-----------|---------|---------|
| **Next.js** | 15 | React framework (App Router) |
| **TypeScript** | Latest | Type safety |
| **React** | 18 | UI library |
| **Tailwind CSS** | Latest | Styling |
| **Shadcn/ui** | Latest | Component library |
| **Zustand** | Latest | Client state management |
| **React Query** | Latest | Server state management |
| **Zod** | Latest | Form validation |

### Infrastructure

| Technology | Purpose |
|-----------|---------|
| **Docker** | Containerization |
| **Docker Compose** | Local orchestration |
| **Turborepo** | Monorepo build system |
| **Uvicorn** | ASGI web server |

### Future Infrastructure

- **AWS** (Phase 2 deployment)
- **GitHub Actions** (CI/CD)
- **CloudWatch** (Monitoring)

## Key Architectural Decisions

### 1. Async Everything (Backend)

**Decision:** Use AsyncIO throughout the backend stack.

**Rationale:**
- Non-blocking I/O for better performance
- Handle more concurrent requests with fewer resources
- Required for monitoring service (60s loops per route)

**Implementation:**
- FastAPI with async endpoints
- SQLAlchemy async engine
- AsyncPG driver for PostgreSQL
- Async Redis client

### 2. Type Safety Across Stack

**Decision:** Enforce strong typing in both frontend and backend.

**Rationale:**
- Catch errors at compile time, not runtime
- Better IDE support and autocomplete
- API contract enforcement

**Implementation:**
- TypeScript strict mode in frontend
- Pydantic v2 for runtime validation in backend
- Auto-generated TypeScript types from OpenAPI schema
- Zod validation for forms

### 3. Layered Architecture

**Decision:** Strict separation of concerns with defined layers.

**Rationale:**
- Clear boundaries between components
- Easy to test (mock dependencies)
- Maintainable and scalable

**Layers:**
```
API Layer (FastAPI Routes)
    ↓
Service Layer (Business Logic)
    ↓
Repository Layer (Data Access)
    ↓
Model Layer (Database Models)
```

### 4. Caching Strategy

**Decision:** Use Redis for caching validation results and session data.

**What to Cache:**
- HOS validation results (TTL: 5 minutes)
- Prediction results (TTL: 15 minutes)
- Session data (TTL: 30 minutes)
- Distance matrix calculations (TTL: 24 hours)

**Rationale:**
- Reduce database load
- Improve response times
- Avoid recomputing expensive operations

### 5. API-First Design

**Decision:** Design API contracts first, implement later.

**Rationale:**
- Frontend and backend can develop in parallel
- Clear contract between teams
- Auto-generated documentation

**Implementation:**
- FastAPI auto-generates OpenAPI schema
- API documentation at `/docs` (Swagger UI)
- TypeScript types generated from schema

## Scalability Approach

### Current Scale (MVP)

- **Target:** 5-10 pilot carriers (5-20 trucks each)
- **Routes:** 100-500 active routes per week
- **Response Time:** <5s for route planning (10 stops)
- **Monitoring:** 60s refresh cycle per route

### Phase 2 Scale (Fleet-Wide)

- **Target:** 50 customers (50-100 trucks each)
- **Routes:** 1,000+ routes per week
- **Response Time:** <10s for fleet-wide optimization (50 drivers, 200 loads)
- **Monitoring:** Distributed monitoring service

### Scalability Strategies

**Horizontal Scaling:**
- Backend API: Multiple replicas behind load balancer
- Monitoring Service: Distributed job queue (Celery + Redis)
- Database: Read replicas for queries

**Vertical Scaling:**
- Optimize TSP algorithm (greedy + 2-opt → OR-Tools VRP)
- Database indexing (driver_id, plan_id, created_at, status)
- Query optimization (N+1 prevention, eager loading)

**Caching:**
- Aggressive caching for validation results
- Distance matrix pre-computation
- CDN for frontend assets

**Database Optimization:**
- Partition tables by date (route plans, monitoring events)
- Archive old data (move completed routes to cold storage)
- Materialized views for analytics

## FMCSA HOS Regulations

SALLY encodes federal HOS regulations into the system:

| Rule | Value | Constant |
|------|-------|----------|
| Max driving hours per day | 11 hours | `MAX_DRIVE_HOURS` |
| Max on-duty hours per day | 14 hours | `MAX_DUTY_HOURS` |
| Required break after driving | 30 minutes | `REQUIRED_BREAK_MINUTES` |
| Break trigger threshold | 8 hours | `BREAK_TRIGGER_HOURS` |
| Minimum rest period | 10 hours | `MIN_REST_HOURS` |
| Sleeper berth long split | 8 hours | `SLEEPER_BERTH_SPLIT_LONG` |
| Sleeper berth short split | 2 hours | `SLEEPER_BERTH_SPLIT_SHORT` |

**References:**
- [FMCSA HOS Summary](https://www.fmcsa.dot.gov/regulations/hours-service/summary-hours-service-regulations)
- Implemented in: `apps/backend-py/app/core/constants.py`

## API Endpoints (Priority Order)

### Primary Endpoints (Route Planning)
1. `POST /api/v1/routes/plan` - Plan complete route
2. `POST /api/v1/routes/update` - Update route with triggers
3. `GET /api/v1/routes/{plan_id}` - Get route status
4. `GET /api/v1/routes/{plan_id}/monitoring` - Get monitoring status

### Alert Endpoints (Dispatcher Notifications)
5. `GET /api/v1/alerts` - List active alerts
6. `POST /api/v1/alerts/{alert_id}/acknowledge` - Acknowledge alert
7. `POST /api/v1/alerts/{alert_id}/resolve` - Resolve alert

### Mock External API Endpoints (POC)
8. `GET /api/v1/external/hos/{driver_id}` - Mock Samsara HOS data
9. `GET /api/v1/external/fuel-prices` - Mock fuel prices
10. `GET /api/v1/external/weather` - Mock weather data

### Component Endpoints (Called by Route Planner)
11. `POST /api/v1/hos/validate` - HOS compliance check
12. `POST /api/v1/rest/recommend` - REST optimization
13. `POST /api/v1/fuel/find-stops` - Fuel stop finding

## Detailed Architecture Documentation

For comprehensive architecture documentation including C4 diagrams, sequence diagrams, and deployment architecture, see:

### C4 Model Diagrams

Located in `.docs/technical/architecture/`:

- **Level 1 - System Context** (`c4-level1-context.puml`) - System boundary and external systems
- **Level 2 - Container** (`c4-level2-container.puml`) - High-level technology stack
- **Level 3 - Backend Components** (`c4-level3-component-backend.puml`) - Backend internal structure
- **Level 3 - Frontend Components** (`c4-level3-component-frontend.puml`) - Dashboard component architecture
- **Level 4 - HOS Engine** (`c4-level4-code-hos-engine.puml`) - HOS Rule Engine class structure
- **Level 4 - Optimization Engine** (`c4-level4-code-optimization-engine.puml`) - REST Engine class structure

### Additional Diagrams

- **Sequence Diagram** (`sequence-rest-optimization.puml`) - End-to-end flow for rest optimization
- **Deployment Diagram** (`deployment-diagram.puml`) - Docker container deployment
- **Data Flow Diagram** (`data-flow-diagram.puml`) - Data flow through the system

### How to View Diagrams

**Option 1: Online (No Installation)**
1. Visit [PlantUML Web Server](http://www.plantuml.com/plantuml/uml/)
2. Copy contents of any `.puml` file from `.docs/technical/architecture/`
3. Paste and view instantly

**Option 2: VS Code Extension**
1. Install "PlantUML" extension by jebbs
2. Open any `.puml` file
3. Press `Alt + D` (or `Option + D` on Mac) to preview

**Option 3: Command Line**
```bash
# Install PlantUML
brew install plantuml graphviz  # macOS

# Render all diagrams
cd .docs/technical/architecture
./render-diagrams.sh
```

### Architecture Documentation Index

- `.docs/technical/architecture/README.md` - Comprehensive architecture guide
- `.docs/technical/architecture/VISUALIZATION_GUIDE.md` - Diagram visualization instructions
- `.docs/technical/C4_MODEL_SUMMARY.md` - C4 model summary
- `.docs/specs/blueprint.md` - Product vision and system architecture

## Next Steps

- **[Tech Stack](/architecture/tech-stack)** - Deep dive into technology choices
- **[System Design](/architecture/system-design)** - Detailed component design
- **[Data Flow](/architecture/data-flow)** - How data moves through the system
- **[API Reference](/api-reference)** - Complete API documentation
- **[Getting Started](/getting-started/quickstart)** - Start building with SALLY
